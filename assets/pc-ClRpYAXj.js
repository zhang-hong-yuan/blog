import{_ as i}from"./index-C58PDwY0.js";import{ao as p,o as n,c as e,a4 as s,q as o,F as m,e as t}from"./@vue-DejhS5Sx.js";import"./element-plus-BrY0m-Us.js";import"./@vueuse-DG8PRMz9.js";import"./@element-plus-BIOyB9cn.js";import"./lodash-es-CapuB_Of.js";import"./@popperjs-Be9rlJlp.js";import"./hammerjs-uHrd7ah6.js";import"./@babel-Cpj98o6Y.js";import"./pinia-B7SS5Sce.js";import"./naive-ui-DvnQ8VCf.js";import"./seemly-BiqVPN66.js";import"./date-fns-x7VUUoCw.js";import"./evtd-CI_DDEu_.js";import"./vooks-BvrI42AR.js";import"./vueuc-DNxWDit6.js";import"./@css-render-Wpowbghw.js";import"./css-render-Ct37b3-v.js";import"./@emotion-WldOFDRm.js";import"./vdirs-DL8EOfHr.js";import"./@juggle-C8OzoCMD.js";import"./@arco-design-CcQ42w85.js";import"./number-precision-BW_FzNZC.js";import"./lodash-DBaaQlBN.js";import"./vue-router-CTzOd6h0.js";import"./jquery-awXEzGOF.js";import"./prismjs-Cy_Hpibq.js";import"./primevue-C3o8vU3d.js";import"./pinia-plugin-persistedstate-RV7uh3T-.js";/* empty css                  *//* empty css                    */const l={},c=t("h2",null,"箭头函数",-1),a=t("p",null,[o("箭头函数是更简短的函数写法。适用于本来需要"),t("strong",null,"匿名函数"),o("的地方。")],-1),_={class:"nocopy"},d=t("dl",null,[t("dt",null,"【param】"),t("dd",null,"参数名称。零参数需要用 () 表示。只有一个参数时不需要括号。(例如 【foo => 1】)"),t("dt",null,"【statements or expression】"),t("dd",null,"多个声明 statements 需要用大括号括起来，而单个表达式时则不需要。表达式 expression 也是该函数的隐式返回值。")],-1),u=t("p",null,"箭头函数不能用作构造函数，无法使用关键字 【new】。",-1),h=t("p",null,"箭头函数没有 【arguments】 动态参数，但是有剩余参数 【...args】。",-1),f=t("p",null,"箭头函数属于表达式函数，因此不存在函数提升。",-1),x=t("p",null,"箭头函数不会创建自己的 【this】，它只会从自己的作用域链的上一层沿用 【this】。",-1),g=t("blockquote",null,"在箭头函数出现之前，每一个新函数都定义了自己的 【this】 值（在构造函数中是一个新的对象；在严格模式下是 【undefined】；在作为“对象方法”调用的函数中指向这个对象；等等）。事实证明，这对于面向对象的编程风格来说并不理想。",-1);function v(k,y){const r=p("code");return n(),e(m,null,[c,a,s((n(),e("pre",_,[o(`([param] [, param]) => { statements } param => expression
`)])),[[r,void 0,"js"]]),d,u,h,s((n(),e("pre",null,[o(`// 基本写法：
const fn1 = () => { }

// 只有一个参数可以省略小括号。如果需要使用默认值的话，一个参数的时候也需要写 ()
const fn2 = x => { }

// 函数体只有一行代码，可以写到一行上，省略花括号 {}，并且无需写 return 直接返回值
const fn3 = (x, y) => x + y

// 如果函数要返回一个对象，则在函数体外面加小括号即可
const fn4 = age => ({ age: age })
console.log(fn4(18)) // {age: 18}`)])),[[r,void 0,"js"]]),f,x,g],64)}const $=i(l,[["render",v]]);export{$ as default};
